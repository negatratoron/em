window.onload = function () {
	Object.prototype.p = function () {
		if (arguments[0]) {
			if (arguments[1]) {
				this[arguments[0]] = arguments[1];
			}
			else {
				return this[arguments[0]];
			}
		}
	};


	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");


	// some quick linear algebra functions...
	var magnitude2 = function (v) {
		var x = v[0];
		var y = v[1];
		return x * x + y * y;
	};
	var magnitude = function (v) {
		var x = v[0];
		var y = v[1];
		return Math.sqrt(x * x + y * y);
	};
	var dot = function (v1, v2) {
		return v1[0] * v2[0] + v1[1] * v2[1];
	};
	var cross = function (v1, v2) {
		return v1[0] * v2[1] - v1[1] * v2[0];
	};
	var crossZ = function (v, z) {
		return [-v[1] * z, v[0] * z];
	};
	var plus = function (v1, v2) {
		return [v1[0] + v2[0], v1[1] + v2[1]];
	};
	var minus = function (v1, v2) {
		return [v1[0] - v2[0], v1[1] - v2[1]];
	};
	var scale = function (v, s) {
		return [v[0] * s, v[1] * s];
	};
	var rotate = function (v, a) {
		var c = Math.cos(a);
		var s = Math.sin(a);
		return [c * v[0] - s * v[1], s * v[0] + c * v[1]];
	};
	var normalize = function (v) {
		return scale(v, 1 / magnitude(v));
	};
	var project = function (v1, v2) {
		return scale(v2, dot(v1, v2) / magnitude2(v2));
	};


	var ec = 0.001; // electric constant
	var mc = 0.01; // magnetic constant
	var g = 0.0; // acceleration due to gravity

	var collisionType = {
		circle: 0,
		convexPoly: 1,
	};

	var mkPhysicsBody = function (obj) {
		obj = obj || {};

		// initialize physics properties to some values
		obj.pos = [0, 0];
		obj.vel = [0, 0];
		obj.mass = 1;
		obj.angle = 0;
		obj.angleVel = 0;
		obj.momentOfInertia = 0.5;
		obj.charge = 0;
		obj.elasticity = 1;

		obj.collisionType = collisionType.circle;
		obj.collisionRadius = 0;
		obj.collisionSize = 0;

		// here are the ways we can interact with physics bodies
		obj.applyForce = function (f) {
			obj.vel = plus(obj.vel, scale(f, 1 / obj.mass));
		};
		obj.applyTorque = function (t) {
			obj.angleVel = obj.angleVel + t / obj.momentOfInertia;
		};

		// some derived propoerties
		obj.electricField = function (p) {
			// We assume all objects are point charges.  This function
			// returns the value of the electric field freely
			// generated by this object, evaluated at point p.
			var pos = obj.pos;

			var displacement = minus(p, pos);
			var distance = magnitude(displacement);
			var area = 4 * Math.PI * distance * distance;
			var e = scale(displacement, obj.charge / (distance * area * ec));
			return e;
		};
		obj.magneticField = function (p) {
			// todo
			return 0;
		};
		return obj;
	};

	var overlap = function (body1, body2) {
		// return a time index shortly before they first collide (if ever)
		// and a "collision point" for each object
		if (body1.collisionType === collisionType.circle &&
			body2.collisionType === collisionType.circle) {
			// just trust that i did the math on paper
			var p = minus(body2.pos, body1.pos);
			var v = minus(body2.vel, body1.vel);
			var r = body1.collisionRadius + body2.collisionRadius;
			var a = magnitude2(v);
			var b = 2 * dot(p, v);
			var c = magnitude2(p) - r * r;
			var desc = b * b - 4 * a * c;
			if (desc >= 0) {
				var a2 = 2 * a;
				var sqrtDesc = Math.sqrt(desc);
				var t1 = (-b - sqrtDesc) / a2;
				var t2 = (-b + sqrtDesc) / a2;
				var t;
				if (t1 >= 0 && t1 <= 1) 
					t = t1;
				if (t2 >= 0 && t2 <= 1)
					t = t2;

				// so t is the positive time index, or null
				if (t >= 0 && t <= 1) {
					var collisionNormal = normalize(plus(p, scale(v, t)));
					return {
						t: t,
						point1: collisionNormal,
						point2: scale(collisionNormal, -1),
					};
				}
			}
		}
		else if (body1.collisionType === collisionType.circle &&
				 body2.collisionType === collisionType.convexPoly) {
			// For each edge, check if the closest point to
			// the center of the circle is inside the circle.
			var p = minus(body1.pos, body2.pos);
			var points = body2.collisionPoints.slice();
			points.push(points[0]);
			for (var i = 0; i < points.length - 1; i++) {
				var point1 = minus(rotate(points[i], body2.angle), p); 
				var point2 = minus(rotate(points[i + 1], body2.angle), p);

				// compute the "velocity" of the edge and the "time
				// index" at which the distance to the center of the
				// circle is minimized
				var pointV = minus(point2, point1);
				var a = magnitude2(pointV);
				var b = 2 * dot(point1, pointV);
				var minT = -b / (2 * a);

				if (minT >= 0 && minT <= 1) {
					var point = plus(point1, scale(pointV, minT));
					if (magnitude(point) <= body1.collisionRadius) {
						var circleNormal = normalize(point);
						return {
							point1: circleNormal,
							point2: {
								i: i,
								t: minT,
							}
						};
					}
				}
			}
		}
	};

	var collide = function (body1, body2) {
		var coll = overlap(body1, body2);
		if (coll) {
			if (body1.collisionType === collisionType.circle &&
				body2.collisionType === collisionType.circle) {
				var t = coll.t;
				var vel1Normal = project(body1.vel, coll.point1);
				var vel2Normal = project(body2.vel, coll.point2);
				var cr = body1.elasticity * body2.elasticity;
				// read the formula off of
				// http://en.wikipedia.org/wiki/Inelastic_collision
				var vel1Normal2 = scale(
					plus(scale(minus(vel2Normal, vel1Normal), cr * body2.mass),
						 plus(scale(vel1Normal, body1.mass),
							  scale(vel2Normal, body2.mass))), 1 / (body1.mass + body2.mass));
				var vel2Normal2 = scale(
					plus(scale(minus(vel1Normal, vel2Normal), cr * body1.mass),
						 plus(scale(vel1Normal, body1.mass),
							  scale(vel2Normal, body2.mass))), 1 / (body1.mass + body2.mass));

				body1.applyForce(scale(minus(vel1Normal2, vel1Normal), body1.mass));
				body2.applyForce(scale(minus(vel2Normal2, vel2Normal), body2.mass));
			}
			else if (body1.collisionType === collisionType.circle &&
					 body2.collisionType === collisionType.convexPoly) {
				var points = body2.collisionPoints.slice();
				points.push(points[0]);
				var pointi = rotate(points[coll.point2.i], body2.angle);
				var pointi2 = rotate(points[coll.point2.i + 1], body2.angle);
				var pointV = minus(pointi2, pointi);
				var point2 = plus(pointi, scale(pointV, coll.point2.t));
				var cr = body1.elasticity * body2.elasticity;
				
				// black magic ahead
				// see http://en.wikipedia.org/wiki/Collision_response
				var j_r = (-1 - cr)
			}
		}
	};

	var mkCircle = function (obj, radius) {
		obj = obj || {};
		mkPhysicsBody(obj);
		obj.collisionRadius = radius;
		obj.collisionSize = radius;
		obj.draw = function (ctx) {
			var pos = obj.pos;
			ctx.save();
			ctx.translate(pos[0], pos[1]);
			if (obj.charge < 0) {
				ctx.strokeStyle = "#0000FF";
				ctx.fillStyle = "#0000FF";
			}
			if (obj.charge === 0) {
				ctx.strokeStyle = "#000000";
				ctx.fillStyle = "#000000";
			}
			if (obj.charge > 0) {
				ctx.strokeStyle = "#FF0000";
				ctx.fillStyle = "#FF0000";
			}
			ctx.beginPath();
			ctx.arc(0, 0, radius, 0, (2 * Math.PI));
			ctx.stroke();
			ctx.fill();
			ctx.restore();
		};
		return obj;
	};

	var mkBlock = function (obj, width, height) {
		obj = obj || {};
		mkPhysicsBody(obj);
		var x = width / 2;
		var y = height / 2;
		obj.mass = width * height / 300;
		obj.momentOfInertia = obj.mass * 3;
		obj.collisionType = collisionType.convexPoly;
		obj.collisionPoints = [[-x, -y],
							   [-x, y],
							   [x, y],
							   [x, -y]];
		obj.draw = function (ctx) {
			var pos = obj.pos;
			ctx.save();
			ctx.translate(pos[0], pos[1]);
			ctx.rotate(obj.angle);
			ctx.beginPath();
			ctx.strokeStyle = "#000000";
			ctx.fillStyle = "#000000";
			ctx.moveTo(-x, -y);
			ctx.lineTo(-x, y);
			ctx.lineTo(x, y);
			ctx.lineTo(x, -y);
			ctx.lineTo(-x, -y);
			ctx.stroke();
			ctx.fill();
			ctx.restore();
		};
		return obj;
	};

	var startPhysicsSystem = function (bodies) {
		setInterval(function () {
			for (var i = 0; i < bodies.length; i++) {
				var body = bodies[i];

				// do collisions
				for (var j = 1 + i; j < bodies.length; j++) {
					var body2 = bodies[j];
					
					collide(body, body2);
				}

				body.pos = plus(body.pos, body.vel);
				body.angle = body.angle + body.angleVel;

				// gravity force vector
				var gf = scale([0, 1], g * body.mass);
				body.applyForce(gf);

				// apply force based on charge and electric and vetical magnetic fields
				if (body.q !== 0) {
					var e = [0, 0];
					var m = 0;
					for (var j = 0; j < bodies.length; j++) {
						if (i !== j) {
							e = plus(e, bodies[j].electricField(body.pos));
							m = m + bodies[j].magneticField(body.pos);
						}
					}
					body.applyForce(scale(e, body.charge));
					body.applyForce(scale(crossZ(body.vel, m), body.charge));
				}
			}
		}, 16);
	};


	var draw = function (ctx, drawables, fps) {
		fps = fps || 60;
		var ms = 1000 / fps;

		var width = ctx.canvas.width;
		var height = ctx.canvas.height;

		setInterval(function () {
			ctx.clearRect(0, 0, width, height);
			drawables.map(function (drawable) {
				drawable.draw(ctx);
			});
		}, 16);
	};


	var mkForceField = function (obj, minXY, maxXY, step) {
		obj = obj || {};
		
		obj.bodies = [];
		obj.draw = function (ctx) {
			for (var i = minXY[0]; i < maxXY[0]; i += step) {
				for (var j = minXY[1]; j < maxXY[1]; j += step) {
					var e = [0, 0];
					for (var k = 0; k < obj.bodies.length; k++) {
						e = plus(e, obj.bodies[k].electricField([i, j]));
					}
					ctx.save();
					ctx.translate(i, j);
					ctx.rotate(Math.atan2(e[1], e[0]));
					var mag = (Math.atan(magnitude(e)) / Math.PI) * step * 0.6 + 0.2 * step;

					ctx.beginPath();
					ctx.moveTo(0, 0);
					ctx.lineTo(mag, 0);
					ctx.lineTo(mag - 3, 3);
					ctx.moveTo(mag, 0);
					ctx.lineTo(mag - 3, -3);
					ctx.stroke();
					ctx.restore();
				}
			}
		};

		return obj;
	};


	var mkWall = function (obj, minXY, maxXY, thickness) {
		
	};

	var mkUniformMagneticField = function (obj, magnitude) {
		obj = obj || {};
		mkPhysicsBody(obj);
		obj.magneticField = function () {
			return magnitude * mc;
		};
		return obj;
	};

	// finally, put the game together
	var circle = mkCircle({}, 8);
	circle.pos = [100, 210];
	circle.vel = [1, -1];
	circle.charge = 1;

	var circle2 = mkCircle({}, 8);
	circle2.pos = [200, 90];
	circle2.vel = [-1, 1];
	circle2.charge = 1;

	var circle3 = mkCircle({}, 8);
	circle3.pos = [85, 20];

	var circle4 = mkCircle({}, 8);
	circle4.pos = [300, 450];
	circle4.charge = 1;
	circle4.vel = [0, -0.9];

	var circle5 = mkCircle({}, 8);
	circle5.pos = [340, 450];
	circle5.charge = -1;
	circle5.vel = [0, 0.9];
	
	var block = mkBlock({}, 120, 10);
	block.pos = [230, 230];

	var ambientMagneticField = mkUniformMagneticField({}, 1);


	var level1Physics = [
		circle,
		circle2,
		circle3,
		circle4,
		circle5,
		// block,
		ambientMagneticField,
	];

	var ff = mkForceField(level1Physics, [0, 0], [640, 480], 40);
	ff.bodies = level1Physics;
	var level1Drawables = [
		circle,
		circle2,
		circle3,
		circle4,
		circle5,
		// block,
		ff,
	];

	startPhysicsSystem(level1Physics);
	draw(ctx, level1Drawables, 60);
};

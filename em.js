window.onload = function () {
	Object.prototype.p = function () {
		if (arguments[0]) {
			if (arguments[1]) {
				this[arguments[0]] = arguments[1];
			}
			else {
				return this[arguments[0]];
			}
		}
	};

	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");


	// some quick linear algebra functions...
	var magnitude2 = function (v) {
		var x = v[0];
		var y = v[1];
		return x * x + y * y;
	};
	var magnitude = function (v) {
		var x = v[0];
		var y = v[1];
		return Math.sqrt(x * x + y * y);
	};
	var dot = function (v1, v2) {
		return v1[0] * v2[0] + v1[1] * v2[1];
	};
	var plus = function (v1, v2) {
		return [v1[0] + v2[0], v1[1] + v2[1]];
	};
	var minus = function (v1, v2) {
		return [v1[0] - v2[0], v1[1] - v2[1]];
	};
	var scale = function (v, s) {
		return [v[0] * s, v[1] * s];
	};
	var normalize = function (v) {
		return scale(v, 1 / magnitude(v));
	};
	var project = function (v1, v2) {
		v2 = normalize(v2);
		return [v1[0] * Math.abs(v2[0]), v1[1] * Math.abs(v2[1])];
	};


	var ec = 0.001; // electric constant
	var g = 0.0; // acceleration due to gravity

	var collisionType = {
		circle: 0,
		convexPoly: 1,
	};

	var mkPhysicsBody = function (obj) {
		obj = obj || {};

		// initialize physics properties to some values
		obj.pos = [0, 0];
		obj.vel = [0, 0];
		obj.mass = 1;
		obj.angle = 0;
		obj.angleVel = 0;
		obj.momentOfInertia = 0.5;
		obj.charge = 0;
		obj.elasticity = 1;

		obj.collisionType = collisionType.circle;
		obj.collisionRadius = 0;
		obj.collisionSize = 0;

		// here are the ways we can interact with physics bodies
		obj.applyForce = function (f) {
			var mass = obj.mass;
			var vel = obj.vel;
			var accel = [f[0] / mass, f[1] / mass];
			obj.vel = plus(vel, accel);
		};

		// some derived propoerties
		obj.electricField = function (p) {
			// We assume all objects are point charges.  This function
			// returns the value of the electric field freely
			// generated by this object, evaluated at point p.
			var pos = obj.pos;

			var displacement = minus(p, pos);
			var distance = magnitude(displacement);
			var area = 4 * Math.PI * distance * distance;
			var e = scale(displacement, obj.charge / (distance * area * ec));
			return e;
		};
		return obj;
	};

	var overlap = function (body1, body2) {
		// return a time index shortly before they first collide (if ever)
		// and a "collision point" for each object
		if (body1.collisionType === collisionType.circle &&
			body2.collisionType === collisionType.circle) {
			// just trust that i did the math on paper
			var p = minus(body2.pos, body1.pos);
			var v = minus(body2.vel, body1.vel);
			var r = body1.collisionRadius + body2.collisionRadius;
			var a = magnitude2(v);
			var b = 2 * dot(p, v);
			var c = magnitude2(p) - r * r;
			var desc = b * b - 4 * a * c;
			if (desc >= 0) {
				var a2 = 2 * a;
				var sqrtDesc = Math.sqrt(desc);
				var t1 = (-b - sqrtDesc) / a2;
				var t2 = (-b + sqrtDesc) / a2;
				var t;
				if (t1 >= 0 && t1 <= 1) 
					t = t1;
				if (t2 >= 0 && t2 <= 1)
					t = t2;

				// so t is the positive time index, or null
				if (t >= 0 && t <= 1) {
					var collisionNormal = normalize(plus(p, scale(v, t)));
					return {
						t: t,
						point1: collisionNormal,
						point2: scale(collisionNormal, -1),
					};
				}
			}
		}
		else if (body1.collisionType === collisionType.circle &&
				 body2.collisionType === collisionType.convexPoly) {
			
		}
	};

	var collide = function (body1, body2) {
		var coll = overlap(body1, body2);
		if (coll) {
			if (body1.collisionType === collisionType.circle &&
				body2.collisionType === collisionType.circle) {
				var t = coll.t;
				var pos1 = plus(body1.pos, scale(body1.vel, t));
				var pos2 = plus(body2.pos, scale(body2.vel, t));
				var vel1Normal = project(body1.vel, coll.point1);
				var vel2Normal = project(body2.vel, coll.point2);
				var cr = body1.elasticity * body2.elasticity;
				// read the formula off of
				// http://en.wikipedia.org/wiki/Inelastic_collision
				var vel1Normal2 = scale(
					plus(scale(minus(vel2Normal, vel1Normal), cr * body2.mass),
						 plus(scale(body1.vel, body1.mass),
							  scale(body2.vel, body2.mass))), 1 / (body1.mass + body2.mass));
				var vel2Normal2 = scale(
					plus(scale(minus(vel1Normal, vel2Normal), cr * body1.mass),
						 plus(scale(vel1Normal, body1.mass),
							  scale(vel2Normal, body2.mass))), 1 / (body1.mass + body2.mass));

				body1.vel = plus(minus(body1.vel, vel1Normal), vel1Normal2);
				body2.vel = plus(minus(body2.vel, vel2Normal), vel2Normal2);
			}
		}
	};

	var mkCircle = function (obj, radius) {
		obj = obj || {};
		mkPhysicsBody(obj);
		obj.collisionRadius = radius;
		obj.collisionSize = radius;
		obj.draw = function (ctx) {
			var pos = obj.pos;
			ctx.save();
			ctx.translate(pos[0], pos[1]);
			if (obj.charge < 0) {
				ctx.strokeStyle = "#0000FF";
				ctx.fillStyle = "#0000FF";
			}
			if (obj.charge === 0) {
				ctx.strokeStyle = "#000000";
				ctx.fillStyle = "#000000";
			}
			if (obj.charge > 0) {
				ctx.strokeStyle = "#FF0000";
				ctx.fillStyle = "#FF0000";
			}
			ctx.beginPath();
			ctx.arc(0, 0, radius, 0, (2 * Math.PI));
			ctx.stroke();
			ctx.fill();
			ctx.restore();
		};
		return obj;
	};

	var mkBlock = function (obj, width, height) {
		obj = obj || {};
		mkPhysicsBody(obj);
		obj
	};

	var startPhysicsSystem = function (bodies) {
		setInterval(function () {
			for (var i = 0; i < bodies.length; i++) {
				var body = bodies[i];

				// do collisions
				for (var j = 1 + i; j < bodies.length; j++) {
					var body2 = bodies[j];
					
					collide(body, body2);
				}

				body.pos = plus(body.pos, body.vel);
				body.angle = body.angle + body.angleVel;

				// gravity force vector
				var gf = scale([0, 1], g * body.mass);
				body.applyForce(gf);

				// apply electric force
				if (body.q !== 0) {
					var e = [0, 0];
					for (var j = 0; j < bodies.length; j++) {
						if (i !== j) {
							e = plus(e, bodies[j].electricField(body.pos));
						}
					}
					body.applyForce(scale(e, body.charge));
				}
			}
		}, 16);
	};


	var draw = function (ctx, drawables, fps) {
		fps = fps || 60;
		var ms = 1000 / fps;

		var width = ctx.canvas.width;
		var height = ctx.canvas.height;

		setInterval(function () {
			ctx.clearRect(0, 0, width, height);
			drawables.map(function (drawable) {
				drawable.draw(ctx);
			});
		}, 16);
	};


	var mkForceField = function (obj, minXY, maxXY, step) {
		obj = obj || {};
		
		obj.bodies = [];
		obj.draw = function (ctx) {
			for (var i = minXY[0]; i < maxXY[0]; i += step) {
				for (var j = minXY[1]; j < maxXY[1]; j += step) {
					var e = [0, 0];
					for (var k = 0; k < obj.bodies.length; k++) {
						e = plus(e, obj.bodies[k].electricField([i, j]));
					}
					ctx.save();
					ctx.translate(i, j);
					ctx.rotate(Math.atan2(e[1], e[0]));
					var mag = (Math.atan(magnitude(e)) / Math.PI) * step * 0.6 + 0.2 * step;

					ctx.beginPath();
					ctx.moveTo(0, 0);
					ctx.lineTo(mag, 0);
					ctx.lineTo(mag - 3, 3);
					ctx.moveTo(mag, 0);
					ctx.lineTo(mag - 3, -3);
					ctx.stroke();
					ctx.restore();
				}
			}
		};

		return obj;
	};




	// finally, put the game together
	var circle = mkCircle({}, 8);
	circle.pos = [100, 210];
	circle.vel = [1, -1];
	circle.charge = 1;

	var circle2 = mkCircle({}, 8);
	circle2.pos = [200, 90];
	circle2.vel = [-1, 1];
	circle2.charge = 1;

	var circle3 = mkCircle({}, 8);
	circle3.pos = [85, 20];


	var circle4 = mkCircle({}, 8);
	circle4.pos = [300, 450];
	circle4.charge = 1;
	circle4.vel = [0, -0.9];

	var circle5 = mkCircle({}, 8);
	circle5.pos = [340, 450];
	circle5.charge = -1;
	circle5.vel = [0, 0.9];


	var level1Physics = [
		circle,
		circle2,
		circle3,
		circle4,
		circle5,
	];

	var ff = mkForceField(level1Physics, [0, 0], [640, 480], 40);
	ff.bodies = level1Physics;
	var level1Drawables = [
		circle,
		circle2,
		circle3,
		circle4,
		circle5,
		ff,
	];

	startPhysicsSystem(level1Physics);
	draw(ctx, level1Drawables, 60);
};
